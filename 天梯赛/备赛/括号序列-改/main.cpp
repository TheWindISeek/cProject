#include<bits/stdc++.h>
#define N 2002
const int MOD = (int)1e9+7;
long dp[N][N];
using namespace std;
/*整个程序还是可以优化的就比如 不需要每次都双重循环 这样还是挺浪费时间的
只需要走到一定程度就可以了
这个最难的还是初始化的问题 当时我就是初始化没有考虑好 就出现了一大堆问题
不过说实话
原问题更困难
我想去研究一下原问题了
还是先说说这题思路吧
其实还是状态转化的问题
首先说明这个问题必然有着最优子结构这一个特征
即子问题的解组成了原问题的解
因为它这个合法字符串的构造就是从最小开始的
而这个过程是可以逆推的 故而才有此性质
而这些子问题之间相互并不独立
由给出的例子 (????)
就可以知道 ？可以是两边多了一个括号
也可以是？和左边那个括号组合在一起
如果生硬的分开的话 需要考虑的情况就太多了
总共9种 实在麻烦
自顶向下行不通
那就自底向上
此时思路其实发生了变化 从原来的判断括号匹配变成了现在的多少个字符的
感觉上是更像图的玩意
不好说
dp的题写得太少了*/
int main()
{
    string s;
    int n;
    scanf("%d\n",&n);
    getline(cin,s);
    //memset(dp,0,sizeof(dp));
    if(s[0] == ')'||s.size()%2)
    {
        printf("0");
        return 0;
    }
    //cout << MOD<<endl;
    dp[1][1] = 1;
    for(int i = 1; i <= n;i++)
    {
        for(int j = 0; j <= i;j++)
        {
            if(j>0&& (s[i-1] == '('||s[i-1] == '?'))
                dp[i][j] += dp[i-1][j-1]%MOD;
            if(s[i-1] == ')'||s[i-1] == '?')
                dp[i][j] +=dp[i-1][j+1]%MOD;
        }
    }
    cout << dp[n][0];
    return 0;
}
